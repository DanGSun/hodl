import json
from socket import socket
import random
import cryptogr as cg
import logging as log
from .proto import recv, send

meta = """HODL_NetP v1"""


def ats(addr):
    return addr[0] + ':' + str(addr[1])


def afs(addr):
    return addr.split(':')[0], int(addr.split(':')[1])


class Peer:
    """
    Class for one peer.
    """

    def __init__(self, addr, netaddrs):
        self.addr = addr
        self.netaddrs = {ats(addr): None for addr in netaddrs}

    def update(self, myaddrs):
        """
        Checks whiteness of addresses
        myaddrs is list of this computer's addresses:
        [[private key1, public key1], ...]
        :type myaddrs: list
        """
        log.debug('Peer.update')
        for addr in self.netaddrs:
            try:
                sock = socket()
                sock.connect(afs(addr))
                mess = {'request': ['peercheck', random.randint(0, 10000)]}
                mess['pubkeys'] = [[addr[1], cg.sign(json.dumps(mess), addr[0])] for addr in myaddrs]
                send(sock, json.dumps(mess).encode())
                sock.listen(1)
                conn = sock.accept()[0]
                data = recv(conn)
                h = cg.h(data.decode('utf-8'))
                data = json.loads(data.decode('utf-8'))
                pubkeys = data['pubkeys']
                for pubkey, sign in pubkeys:
                    if not cg.verify_sign(sign, h, pubkey):
                        pubkeys.remove([pubkey, sign])
                if self.addr in pubkeys:
                    self.netaddrs[addr] = True
                else:
                    self.netaddrs.pop(addr)
                self.netaddrs[addr] = False
            except Exception as e:
                log.debug('Peer.update: exception: ' + str(e))
                self.netaddrs[addr] = False

    def connect(self, peers):
        """Generate sockets to all IP addresses for this peer"""
        log.debug('Peer.connect: Connecting to peer. self.netaddrs: ' + str(self.netaddrs) + '\n self.addr' + str(
                self.addr))
        sockets = []
        for addr, white in zip(self.netaddrs.keys(), self.netaddrs.values()):
            log.debug('Peer.connect: connecting to ' + str(addr) + '. Whiteness: ' + str(white))
            try:
                if white:
                    sock = socket()
                    sock.connect(afs(addr))
                    sockets.append(sock)
                else:
                    sockets.append(peers.white_conn_to(self.addr))
            except Exception as e:
                log.debug('Peer.connect: exception while connecting: ' + str(e))
        return sockets

    def connect_white(self):
        sockets = []
        for addr, white in zip(self.netaddrs.keys(), self.netaddrs.values()):
            if white:
                sock = socket()
                sock.connect(afs(addr))
                sockets.append(sock)
        if not socket:
            return
        return sockets

    def __str__(self):
        return json.dumps([self.addr, self.netaddrs])

    @classmethod
    def from_json(cls, s):
        """
        Restore peer from json string generated by str(peer)
        :type s: str
        :return: Peer
        """
        s = json.loads(s)
        self = cls(s[0], s[1])
        return self


class Peers(set):
    """
    Class for storing peers.
    It is a set of peers(class Peer)
    """

    def save(self, file):
        """
        Save peers to file
        :type file: str
        :return:
        """
        with open(file, 'w') as f:
            f.write(str(self))

    def __str(self):
        return json.dumps([json.dumps(peer) for peer in list(self)])

    @classmethod
    def from_json(cls, s):
        self = cls()
        for peer in json.loads(f.read()):
            self.add(Peer.from_json(peer))
        return self

    @classmethod
    def open(cls, file):
        """
        Restore peers from file
        :type file: str
        :return:
        """
        with open(file, 'r') as f:
            self = cls.from_json(f.read())
        return self

    def srchbyaddr(self, addr):
        """
        Search peer in self.
        addr is peer's public key.
        :type addr: str
        :return:
        """
        for p in self:
            if p.addr == addr:
                return True, p
        return False, None

    def white_conn_to(self, to):
        for peer in self:
            socks = peer.connect_white()
            if socks:
                send(socks[0], json.dumps([meta, to]))
                return socks[0]

    def update(self, myaddrs):
        log.debug('Peers.update')
        for peer in self:
            peer.update(myaddrs)
