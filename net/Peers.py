import json
from socket import socket
import random
import cryptogr as cg


meta = """HODL_NetP v1"""


def ats(addr):
    return addr[0] + ':' + str(addr[1])


def afs(addr):
    return (addr.split(':')[0], int(addr.split(':')[1]))


class Peer:
    """
    Class for one peer.
    """
    def __init__(self, addr, netaddrs, log=None):
        self.addr = addr
        self.netaddrs = {ats(addr): None for addr in netaddrs}

    def update(self, myaddrs, log=None):
        """
        Checks whiteness of addresses
        myaddrs is list of this computer's addresses:
        [[private key1, public key1], ...]
        :param myaddrs: list
        """
        if log:
            log.debug('Peer.update')
        for addr in self.netaddrs:
            try:
                sock = socket()
                sock.connect(afs(addr))
                mess = {'request': ['peercheck', random.randint(0, 10000)]}
                mess['pubkeys'] = [[addr[1], cg.sign(json.dumps(mess), addr[0])] for addr in myaddrs]
                sock.send(json.dumps(mess).encode())
                sock.listen(1)
                conn = sock.accept()[0]
                data = b''
                while True:
                    p = conn.recv(1024)
                    data += p
                    if not p:
                        break
                h = cg.h(data.decode('utf-8'))
                data = json.loads(data.decode('utf-8'))
                pubkeys = data['pubkeys']
                for pubkey, sign in pubkeys:
                    if not cg.verify_sign(sign, h, pubkey):
                        pubkeys.remove([pubkey, sign])
                if self.addr in pubkeys:
                    self.netaddrs[addr] = True
                else:
                    self.netaddrs.pop(addr)
                self.netaddrs[addr] = False
            except Exception as e:
                if log:
                    log.debug('Peer.update: exception: ' + str(e))
                self.netaddrs[addr] = False

    def connect(self, peers, log=None):
        """Generate sockets to all IP addresses for this peer"""
        if log:
            log.debug('Peer.connect: Connecting to peer. self.netaddrs: ' + str(self.netaddrs) + '\n self.addr' + str(self.addr))
        sockets = []
        for addr, white in zip(self.netaddrs.keys(), self.netaddrs.values()):
            if log:
                log.debug('Peer.connect: connecting to ' + str(addr) + '. Whiteness: ' + str(white))
            try:
                if white:
                    sock = socket()
                    sock.connect(afs(addr))
                    sockets.append(sock)
                else:
                    sockets.append(peers.white_conn_to(self.addr))
            except Exception as e:
                if log:
                    log.debug('Peer.connect: exception while connecting: ' + str(e))
        return sockets

    def connect_white(self):
        sockets = []
        for addr, white in zip(self.netaddrs.keys(), self.netaddrs.values()):
            if white:
                sock = socket()
                sock.connect(afs(addr))
                sockets.append(sock)
        if sockets == []:
            return
        else:
            return sockets

    def __str__(self):
        return json.dumps([self.addr, self.netaddrs])

    @classmethod
    def from_json(cls, s):
        """
        Restore peer from json string generated by str(peer)
        :param s: str
        :return: Peer
        """
        s = json.loads(s)
        self = cls(s[0], s[1])
        return self


class Peers(set):
    """
    Class for storing peers.
    It is a set of peers(class Peer)
    """
    def save(self, file):
        """
        Save peers to file
        :param file: str
        :return:
        """
        with open(file, 'w') as f:
            f.write(json.dumps([json.dumps(peer) for peer in list(self)]))

    @classmethod
    def open(cls, file):
        """
        Restore peers from file
        :param file: str
        :return:
        """
        self = cls()
        with open(file, 'r') as f:
            for peer in json.loads(f.read()):
                self.add(Peer.from_json(peer))
        return self

    def srchbyaddr(self, addr):
        """
        Search peer in self.
        addr is peer's public key.
        :param addr: str
        :return:
        """
        for p in self:
            if p.addr == addr:
                return (True, p)
        return (False, None)

    def white_conn_to(self, to):
        for peer in self:
            socks = peer.connect_white()
            if socks:
                socks[0].send(json.dumps([meta, to]))
                return socks[0]

    def update(self, myaddrs, log=None):
        if log:
            log.debug('Peers.update')
        for peer in self:
            peer.update(myaddrs, log=log)
